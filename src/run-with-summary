#!/usr/bin/env bash

usage() {
  cat <<'USAGE'
Usage: run-with-summary <command and args>

Executes the given command, streams its output, and writes a Markdown summary to $FILE.

Environment variables:
  HEADING           Custom text for the h1 tag. (default: "Running Command...")
  SUMMARY           Short text to display below the header.
  SUCCESS           Custom success message (default: "Command succeeded").
  ERROR             Custom error message (default: "Command failed").
  DEBUG             If set (non-empty), include User/Host/Directory in the summary.
  FILE              The file to append the markdown report to. (default: /tmp/summary.md)
  SHOW              If set, echo the summary after the command is run.

Examples:
  run-with-summary scripts/deploy.sh

  HEADING="Deployment" \
  SUMMARY="Deploy script running as an example." \
  SUCCESS="Deploy successful! :rocket:" \
  ERROR="DEPLOY FAILED! :x:" \
  DEBUG=1 \
  FILE=reports/$(date).md \
    run-with-summary scripts/deploy.sh

USAGE
}

set -e

# Customize the success and error messages.
export command="$@"
export summary=${SUMMARY:-"Started $(date)"}
export success=${SUCCESS:-"Command executed successfully."}
export error=${ERROR:-"Command failed"}
export debug=${DEBUG:-""}

export date_format_readable="%a %b %d %Y %T %Z"
export date_format_filename="%Y-%m-%d--%H:%M:%S-%Z"

# Export to GITHUB_STEP_SUMMARY, if it exists and FILE is empty
FILE=${FILE:-${GITHUB_STEP_SUMMARY}}

# Temporary file to store output.
export temp_output_file=$(mktemp)

if [ -z "$command" ]; then
    usage
    exit 1
fi

format_date() {
  time="${1:-$(date '+%s')}"
  format="${2:-$date_format_filename}"
  date -d "@$time" "+$format" 2>/dev/null || date -r "$time" "+$format"
}

# Format output into markdown report
format_output() {
    local duration=$((end_time - start_time))
    local start_date=$(format_date "$start_time" "$date_format_readable")
    local end_date=$(format_date "$end_time" "$date_format_readable")

    local message="$error"
    if [ "$exit_code" -eq 0 ]; then
        message="$success"
    fi

    echo "# $message"
    echo "$summary"
    format_code "$command"

    echo \`\`\`
    cat $temp_output_file
    echo \`\`\`

    echo

    echo "| Command    | \`$command\`"
    echo "|------------|-----------------------"
    echo "| Exit Code  | \`$exit_code\`"
    echo "| Start Time | $start_date"
    echo "| End Time   | $end_date"
    echo "| Duration   | ${duration}s"

    if [[ -n $debug ]]; then
      echo "| User             | \`$(whoami)\` "
      echo "| Host             | \`$(hostname -f)\`"
      echo "| Directory        | \`$(pwd)"\`
      echo "| Temp output file | \`$temp_output_file\`"
      echo "| Summary file     | \`$file\`"
    fi
    echo
}

format_code() {
  echo "\`\`\`"
  echo $1
  echo "\`\`\`"
}

export file=${FILE:-"/tmp/summary.$(format_date).md"}

# Record start time 
start_time=$(date '+%s')

# Execute command and pipe output to both terminal and temp file
set +o pipefail
$command 2>&1 | tee -a "$temp_output_file"

# Save exit code.
exit_code=${PIPESTATUS[0]}

# Save end time.
end_time=$(date '+%s')

# Generate markdown report
format_output >> "$file"
echo
echo "Summary saved to $file"

if [[ -n $SHOW ]]; then
  echo
  cat $file
fi


# Exit same as command.
exit "$exit_code"
